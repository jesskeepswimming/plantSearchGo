{"ast":null,"code":"import { LngLat, Point } from 'mapbox-gl';\nexport var anchors = ['center', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];\nexport var anchorTranslates = {\n  center: 'translate(-50%, -50%)',\n  top: 'translate(-50%, 0)',\n  left: 'translate(0, -50%)',\n  right: 'translate(-100%, -50%)',\n  bottom: 'translate(-50%, -100%)',\n  'top-left': 'translate(0, 0)',\n  'top-right': 'translate(-100%, 0)',\n  'bottom-left': 'translate(0, -100%)',\n  'bottom-right': 'translate(-100%, -100%)'\n};\nvar defaultElement = {\n  offsetWidth: 0,\n  offsetHeight: 0\n};\nvar defaultPoint = [0, 0];\n\nvar projectCoordinates = function (map, coordinates) {\n  return map.project(LngLat.convert(coordinates));\n};\n\nvar calculateAnchor = function (map, offsets, position, _a) {\n  var _b = _a === void 0 ? defaultElement : _a,\n      offsetHeight = _b.offsetHeight,\n      offsetWidth = _b.offsetWidth;\n\n  var anchor = [];\n\n  if (position.y + offsets.bottom.y - offsetHeight < 0) {\n    anchor = [anchors[1]];\n  } else if (position.y + offsets.top.y + offsetHeight > map.transform.height) {\n    anchor = [anchors[2]];\n  }\n\n  if (position.x < offsetWidth / 2) {\n    anchor.push(anchors[3]);\n  } else if (position.x > map.transform.width - offsetWidth / 2) {\n    anchor.push(anchors[4]);\n  }\n\n  if (anchor.length === 0) {\n    return anchors[2];\n  }\n\n  return anchor.join('-');\n};\n\nvar normalizedOffsets = function (offset) {\n  if (!offset) {\n    return normalizedOffsets(new Point(0, 0));\n  }\n\n  if (typeof offset === 'number') {\n    var cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n    return {\n      center: new Point(offset, offset),\n      top: new Point(0, offset),\n      bottom: new Point(0, -offset),\n      left: new Point(offset, 0),\n      right: new Point(-offset, 0),\n      'top-left': new Point(cornerOffset, cornerOffset),\n      'top-right': new Point(-cornerOffset, cornerOffset),\n      'bottom-left': new Point(cornerOffset, -cornerOffset),\n      'bottom-right': new Point(-cornerOffset, -cornerOffset)\n    };\n  }\n\n  if (offset instanceof Point || Array.isArray(offset)) {\n    return anchors.reduce(function (res, anchor) {\n      res[anchor] = Point.convert(offset);\n      return res;\n    }, {});\n  }\n\n  return anchors.reduce(function (res, anchor) {\n    res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n    return res;\n  }, {});\n};\n\nexport var overlayState = function (props, map, container) {\n  var position = projectCoordinates(map, props.coordinates);\n  var offsets = normalizedOffsets(props.offset);\n  var anchor = props.anchor || calculateAnchor(map, offsets, position, container);\n  return {\n    anchor: anchor,\n    position: position,\n    offset: offsets[anchor]\n  };\n};\n\nvar moveTranslate = function (point) {\n  return point ? \"translate(\" + point.x.toFixed(0) + \"px, \" + point.y.toFixed(0) + \"px)\" : '';\n};\n\nexport var overlayTransform = function (_a) {\n  var anchor = _a.anchor,\n      position = _a.position,\n      offset = _a.offset;\n  var res = [];\n\n  if (position) {\n    res.push(moveTranslate(position));\n  }\n\n  if (offset && offset.x !== undefined && offset.y !== undefined) {\n    res.push(moveTranslate(offset));\n  }\n\n  if (anchor) {\n    res.push(anchorTranslates[anchor]);\n  }\n\n  return res;\n};","map":{"version":3,"sources":["../../src/util/overlays.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { LngLat, Point } from 'mapbox-gl';\nexport var anchors = [\n    'center',\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'top-left',\n    'top-right',\n    'bottom-left',\n    'bottom-right'\n];\nexport var anchorTranslates = {\n    center: 'translate(-50%, -50%)',\n    top: 'translate(-50%, 0)',\n    left: 'translate(0, -50%)',\n    right: 'translate(-100%, -50%)',\n    bottom: 'translate(-50%, -100%)',\n    'top-left': 'translate(0, 0)',\n    'top-right': 'translate(-100%, 0)',\n    'bottom-left': 'translate(0, -100%)',\n    'bottom-right': 'translate(-100%, -100%)'\n};\nvar defaultElement = { offsetWidth: 0, offsetHeight: 0 };\nvar defaultPoint = [0, 0];\nvar projectCoordinates = function (map, coordinates) {\n    return map.project(LngLat.convert(coordinates));\n};\nvar calculateAnchor = function (map, offsets, position, _a) {\n    var _b = _a === void 0 ? defaultElement : _a, offsetHeight = _b.offsetHeight, offsetWidth = _b.offsetWidth;\n    var anchor = [];\n    if (position.y + offsets.bottom.y - offsetHeight < 0) {\n        anchor = [anchors[1]];\n    }\n    else if (position.y + offsets.top.y + offsetHeight >\n        map.transform.height) {\n        anchor = [anchors[2]];\n    }\n    if (position.x < offsetWidth / 2) {\n        anchor.push(anchors[3]);\n    }\n    else if (position.x > map.transform.width - offsetWidth / 2) {\n        anchor.push(anchors[4]);\n    }\n    if (anchor.length === 0) {\n        return anchors[2];\n    }\n    return anchor.join('-');\n};\nvar normalizedOffsets = function (offset) {\n    if (!offset) {\n        return normalizedOffsets(new Point(0, 0));\n    }\n    if (typeof offset === 'number') {\n        var cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n        return {\n            center: new Point(offset, offset),\n            top: new Point(0, offset),\n            bottom: new Point(0, -offset),\n            left: new Point(offset, 0),\n            right: new Point(-offset, 0),\n            'top-left': new Point(cornerOffset, cornerOffset),\n            'top-right': new Point(-cornerOffset, cornerOffset),\n            'bottom-left': new Point(cornerOffset, -cornerOffset),\n            'bottom-right': new Point(-cornerOffset, -cornerOffset)\n        };\n    }\n    if (offset instanceof Point || Array.isArray(offset)) {\n        return anchors.reduce(function (res, anchor) {\n            res[anchor] = Point.convert(offset);\n            return res;\n        }, {});\n    }\n    return anchors.reduce(function (res, anchor) {\n        res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n        return res;\n    }, {});\n};\nexport var overlayState = function (props, map, container) {\n    var position = projectCoordinates(map, props.coordinates);\n    var offsets = normalizedOffsets(props.offset);\n    var anchor = props.anchor || calculateAnchor(map, offsets, position, container);\n    return {\n        anchor: anchor,\n        position: position,\n        offset: offsets[anchor]\n    };\n};\nvar moveTranslate = function (point) {\n    return point ? \"translate(\" + point.x.toFixed(0) + \"px, \" + point.y.toFixed(0) + \"px)\" : '';\n};\nexport var overlayTransform = function (_a) {\n    var anchor = _a.anchor, position = _a.position, offset = _a.offset;\n    var res = [];\n    if (position) {\n        res.push(moveTranslate(position));\n    }\n    if (offset && offset.x !== undefined && offset.y !== undefined) {\n        res.push(moveTranslate(offset));\n    }\n    if (anchor) {\n        res.push(anchorTranslates[anchor]);\n    }\n    return res;\n};\n//# sourceMappingURL=overlays.js.map"]},"metadata":{},"sourceType":"module"}